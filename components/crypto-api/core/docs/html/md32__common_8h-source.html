<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>md32_common.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>md32_common.h</h1><a href="md32__common_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* crypto/md32_common.h */</span>
00002 <span class="comment">/* ====================================================================</span>
00003 <span class="comment"> * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment"> * modification, are permitted provided that the following conditions</span>
00007 <span class="comment"> * are met:</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
00010 <span class="comment"> *    notice, this list of conditions and the following disclaimer. </span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
00013 <span class="comment"> *    notice, this list of conditions and the following disclaimer in</span>
00014 <span class="comment"> *    the documentation and/or other materials provided with the</span>
00015 <span class="comment"> *    distribution.</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * 3. All advertising materials mentioning features or use of this</span>
00018 <span class="comment"> *    software must display the following acknowledgment:</span>
00019 <span class="comment"> *    "This product includes software developed by the OpenSSL Project</span>
00020 <span class="comment"> *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"</span>
00021 <span class="comment"> *</span>
00022 <span class="comment"> * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to</span>
00023 <span class="comment"> *    endorse or promote products derived from this software without</span>
00024 <span class="comment"> *    prior written permission. For written permission, please contact</span>
00025 <span class="comment"> *    licensing@OpenSSL.org.</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> * 5. Products derived from this software may not be called "OpenSSL"</span>
00028 <span class="comment"> *    nor may "OpenSSL" appear in their names without prior written</span>
00029 <span class="comment"> *    permission of the OpenSSL Project.</span>
00030 <span class="comment"> *</span>
00031 <span class="comment"> * 6. Redistributions of any form whatsoever must retain the following</span>
00032 <span class="comment"> *    acknowledgment:</span>
00033 <span class="comment"> *    "This product includes software developed by the OpenSSL Project</span>
00034 <span class="comment"> *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"</span>
00035 <span class="comment"> *</span>
00036 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY</span>
00037 <span class="comment"> * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
00038 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
00039 <span class="comment"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR</span>
00040 <span class="comment"> * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00041 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
00042 <span class="comment"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
00043 <span class="comment"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
00044 <span class="comment"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
00045 <span class="comment"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
00046 <span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED</span>
00047 <span class="comment"> * OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00048 <span class="comment"> * ====================================================================</span>
00049 <span class="comment"> *</span>
00050 <span class="comment"> * This product includes cryptographic software written by Eric Young</span>
00051 <span class="comment"> * (eay@cryptsoft.com).  This product includes software written by Tim</span>
00052 <span class="comment"> * Hudson (tjh@cryptsoft.com).</span>
00053 <span class="comment"> *</span>
00054 <span class="comment"> */</span>
00055 <span class="comment">/*</span>
00056 <span class="comment">   Copyright (c) 2003-2005 Cavium Networks (support@cavium.com). All rights</span>
00057 <span class="comment">   reserved.</span>
00058 <span class="comment"></span>
00059 <span class="comment">   Redistribution and use in source and binary forms, with or without</span>
00060 <span class="comment">   modification, are permitted provided that the following conditions are met:</span>
00061 <span class="comment">   1. Redistributions of source code must retain the above copyright notice,</span>
00062 <span class="comment">   this list of conditions and the following disclaimer.</span>
00063 <span class="comment">   2. Redistributions in binary form must reproduce the above copyright notice,</span>
00064 <span class="comment">   this list of conditions and the following disclaimer in the documentation</span>
00065 <span class="comment">   and/or other materials provided with the distribution.</span>
00066 <span class="comment">   3. All advertising materials mentioning features or use of this software</span>
00067 <span class="comment">   must display the following acknowledgement:</span>
00068 <span class="comment">   This product includes software developed by Cavium Networks</span>
00069 <span class="comment">   4. Cavium Networks' name may not be used to endorse or promote products</span>
00070 <span class="comment">   derived from this software without specific prior written permission.</span>
00071 <span class="comment"></span>
00072 <span class="comment">   This Software, including technical data, may be subject to U.S. export</span>
00073 <span class="comment">   control laws, including the U.S. Export Administration Act and its</span>
00074 <span class="comment">   associated regulations, and may be subject to export or import regulations</span>
00075 <span class="comment">   in other countries. You warrant that You will comply strictly in all</span>
00076 <span class="comment">   respects with all such regulations and acknowledge that you have the</span>
00077 <span class="comment">   responsibility to obtain licenses to export, re-export or import the</span>
00078 <span class="comment">   Software.</span>
00079 <span class="comment"></span>
00080 <span class="comment">   TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND</span>
00081 <span class="comment">   WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES,</span>
00082 <span class="comment">   EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO THE</span>
00083 <span class="comment">   SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR</span>
00084 <span class="comment">   DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM</span>
00085 <span class="comment">   SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,</span>
00086 <span class="comment">   MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF</span>
00087 <span class="comment">   VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR</span>
00088 <span class="comment">   CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR</span>
00089 <span class="comment">   PERFORMANCE OF THE SOFTWARE LIES WITH YOU.</span>
00090 <span class="comment"> */</span>
00091 
00092 <span class="comment">/*</span>
00093 <span class="comment"> * This is a generic 32 bit "collector" for message digest algorithms.</span>
00094 <span class="comment"> * Whenever needed it collects input character stream into chunks of</span>
00095 <span class="comment"> * 32 bit values and invokes a block function that performs actual hash</span>
00096 <span class="comment"> * calculations.</span>
00097 <span class="comment"> *</span>
00098 <span class="comment"> * Porting guide.</span>
00099 <span class="comment"> *</span>
00100 <span class="comment"> * Obligatory macros:</span>
00101 <span class="comment"> *</span>
00102 <span class="comment"> * DATA_ORDER_IS_BIG_ENDIAN or DATA_ORDER_IS_LITTLE_ENDIAN</span>
00103 <span class="comment"> *      this macro defines byte order of input stream.</span>
00104 <span class="comment"> * HASH_CBLOCK</span>
00105 <span class="comment"> *      size of a unit chunk HASH_BLOCK operates on.</span>
00106 <span class="comment"> * HASH_LONG</span>
00107 <span class="comment"> *      has to be at lest 32 bit wide, if it's wider, then</span>
00108 <span class="comment"> *      HASH_LONG_LOG2 *has to* be defined along</span>
00109 <span class="comment"> * HASH_CTX</span>
00110 <span class="comment"> *      context structure that at least contains following</span>
00111 <span class="comment"> *      members:</span>
00112 <span class="comment"> *              typedef struct {</span>
00113 <span class="comment"> *                      ...</span>
00114 <span class="comment"> *                      HASH_LONG       Nl,Nh;</span>
00115 <span class="comment"> *                      HASH_LONG       data[HASH_LBLOCK];</span>
00116 <span class="comment"> *                      int             num;</span>
00117 <span class="comment"> *                      ...</span>
00118 <span class="comment"> *                      } HASH_CTX;</span>
00119 <span class="comment"> * HASH_UPDATE</span>
00120 <span class="comment"> *      name of "Update" function, implemented here.</span>
00121 <span class="comment"> * HASH_TRANSFORM</span>
00122 <span class="comment"> *      name of "Transform" function, implemented here.</span>
00123 <span class="comment"> * HASH_FINAL</span>
00124 <span class="comment"> *      name of "Final" function, implemented here.</span>
00125 <span class="comment"> * HASH_BLOCK_HOST_ORDER</span>
00126 <span class="comment"> *      name of "block" function treating *aligned* input message</span>
00127 <span class="comment"> *      in host byte order, implemented externally.</span>
00128 <span class="comment"> * HASH_BLOCK_DATA_ORDER</span>
00129 <span class="comment"> *      name of "block" function treating *unaligned* input message</span>
00130 <span class="comment"> *      in original (data) byte order, implemented externally (it</span>
00131 <span class="comment"> *      actually is optional if data and host are of the same</span>
00132 <span class="comment"> *      "endianess").</span>
00133 <span class="comment"> * HASH_MAKE_STRING</span>
00134 <span class="comment"> *      macro convering context variables to an ASCII hash string.</span>
00135 <span class="comment"> *</span>
00136 <span class="comment"> * Optional macros:</span>
00137 <span class="comment"> *</span>
00138 <span class="comment"> * B_ENDIAN or L_ENDIAN</span>
00139 <span class="comment"> *      defines host byte-order.</span>
00140 <span class="comment"> * HASH_LONG_LOG2</span>
00141 <span class="comment"> *      defaults to 2 if not states otherwise.</span>
00142 <span class="comment"> * HASH_LBLOCK</span>
00143 <span class="comment"> *      assumed to be HASH_CBLOCK/4 if not stated otherwise.</span>
00144 <span class="comment"> * HASH_BLOCK_DATA_ORDER_ALIGNED</span>
00145 <span class="comment"> *      alternative "block" function capable of treating</span>
00146 <span class="comment"> *      aligned input message in original (data) order,</span>
00147 <span class="comment"> *      implemented externally.</span>
00148 <span class="comment"> *</span>
00149 <span class="comment"> * MD5 example:</span>
00150 <span class="comment"> *</span>
00151 <span class="comment"> *      #define DATA_ORDER_IS_LITTLE_ENDIAN</span>
00152 <span class="comment"> *</span>
00153 <span class="comment"> *      #define HASH_LONG               MD5_LONG</span>
00154 <span class="comment"> *      #define HASH_LONG_LOG2          MD5_LONG_LOG2</span>
00155 <span class="comment"> *      #define HASH_CTX                MD5_CTX</span>
00156 <span class="comment"> *      #define HASH_CBLOCK             MD5_CBLOCK</span>
00157 <span class="comment"> *      #define HASH_LBLOCK             MD5_LBLOCK</span>
00158 <span class="comment"> *      #define HASH_UPDATE             MD5_Update</span>
00159 <span class="comment"> *      #define HASH_TRANSFORM          MD5_Transform</span>
00160 <span class="comment"> *      #define HASH_FINAL              MD5_Final</span>
00161 <span class="comment"> *      #define HASH_BLOCK_HOST_ORDER   md5_block_host_order</span>
00162 <span class="comment"> *      #define HASH_BLOCK_DATA_ORDER   md5_block_data_order</span>
00163 <span class="comment"> *</span>
00164 <span class="comment"> *                                      &lt;appro@fy.chalmers.se&gt;</span>
00165 <span class="comment"> */</span>
00166 
00167 <span class="preprocessor">#if !defined(DATA_ORDER_IS_BIG_ENDIAN) &amp;&amp; !defined(DATA_ORDER_IS_LITTLE_ENDIAN)</span>
00168 <span class="preprocessor"></span><span class="preprocessor">#error "DATA_ORDER must be defined!"</span>
00169 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00170 <span class="preprocessor"></span>
00171 <span class="preprocessor">#ifndef HASH_CBLOCK</span>
00172 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_CBLOCK must be defined!"</span>
00173 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#ifndef HASH_LONG</span>
00175 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_LONG must be defined!"</span>
00176 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#ifndef HASH_CTX</span>
00178 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_CTX must be defined!"</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00180 <span class="preprocessor"></span>
00181 <span class="preprocessor">#ifndef HASH_UPDATE</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_UPDATE must be defined!"</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#ifndef HASH_TRANSFORM</span>
00185 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_TRANSFORM must be defined!"</span>
00186 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00187 <span class="preprocessor"></span><span class="preprocessor">#ifndef HASH_FINAL</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_FINAL must be defined!"</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00190 <span class="preprocessor"></span>
00191 <span class="preprocessor">#ifndef HASH_BLOCK_HOST_ORDER</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_BLOCK_HOST_ORDER must be defined!"</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00194 <span class="preprocessor"></span>
00195 <span class="preprocessor">#if 0</span>
00196 <span class="preprocessor"></span><span class="comment">/*</span>
00197 <span class="comment"> * Moved below as it's required only if HASH_BLOCK_DATA_ORDER_ALIGNED</span>
00198 <span class="comment"> * isn't defined.</span>
00199 <span class="comment"> */</span>
00200 <span class="preprocessor">#ifndef HASH_BLOCK_DATA_ORDER</span>
00201 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_BLOCK_DATA_ORDER must be defined!"</span>
00202 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00203 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00204 <span class="preprocessor"></span>
00205 <span class="preprocessor">#ifndef HASH_LBLOCK</span>
<a name="l00206"></a><a class="code" href="md32__common_8h.html#a0">00206</a> <span class="preprocessor"></span><span class="preprocessor">#define HASH_LBLOCK (HASH_CBLOCK/4)</span>
00207 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00208 <span class="preprocessor"></span>
00209 <span class="preprocessor">#ifndef HASH_LONG_LOG2</span>
<a name="l00210"></a><a class="code" href="md32__common_8h.html#a1">00210</a> <span class="preprocessor"></span><span class="preprocessor">#define HASH_LONG_LOG2  2</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00212 <span class="preprocessor"></span>
00213 <span class="comment">/*</span>
00214 <span class="comment"> * Engage compiler specific rotate intrinsic function if available.</span>
00215 <span class="comment"> */</span>
00216 <span class="preprocessor">#undef ROTATE</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#ifndef PEDANTIC</span>
00218 <span class="preprocessor"></span><span class="preprocessor"># if 0                          </span><span class="comment">/* defined(_MSC_VER) */</span>
00219 <span class="preprocessor">#  define ROTATE(a,n)   _lrotl(a,n)</span>
00220 <span class="preprocessor"></span><span class="preprocessor"># elif defined(__MWERKS__)</span>
00221 <span class="preprocessor"></span><span class="preprocessor">#  if defined(__POWERPC__)</span>
00222 <span class="preprocessor"></span><span class="preprocessor">#   define ROTATE(a,n)  __rlwinm(a,n,0,31)</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(__MC68K__)</span>
00224 <span class="preprocessor"></span>    <span class="comment">/* Motorola specific tweak. &lt;appro@fy.chalmers.se&gt; */</span>
00225 <span class="preprocessor">#   define ROTATE(a,n)  ( n&lt;24 ? __rol(a,n) : __ror(a,32-n) )</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#   define ROTATE(a,n)  __rol(a,n)</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
00229 <span class="preprocessor"></span><span class="preprocessor"># elif defined(__GNUC__) &amp;&amp; __GNUC__&gt;=2 &amp;&amp; !defined(OPENSSL_NO_ASM) &amp;&amp; !defined(OPENSSL_NO_INLINE_ASM)</span>
00230 <span class="preprocessor"></span>  <span class="comment">/*</span>
00231 <span class="comment">   * Some GNU C inline assembler templates. Note that these are</span>
00232 <span class="comment">   * rotates by *constant* number of bits! But that's exactly</span>
00233 <span class="comment">   * what we need here...</span>
00234 <span class="comment">   *</span>
00235 <span class="comment">   *                                    &lt;appro@fy.chalmers.se&gt;</span>
00236 <span class="comment">   */</span>
00237 <span class="preprocessor">#  if defined(__i386) || defined(__i386__) || defined(__x86_64) || defined(__x86_64__)</span>
00238 <span class="preprocessor"></span><span class="preprocessor">#   define ROTATE(a,n)  ({ register unsigned int ret;   \</span>
00239 <span class="preprocessor">                asm (           \</span>
00240 <span class="preprocessor">                "roll %1,%0"        \</span>
00241 <span class="preprocessor">                : "=r"(ret)     \</span>
00242 <span class="preprocessor">                : "I"(n), "0"(a)    \</span>
00243 <span class="preprocessor">                : "cc");        \</span>
00244 <span class="preprocessor">               ret;             \</span>
00245 <span class="preprocessor">            })</span>
00246 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(__powerpc) || defined(__ppc)</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#   define ROTATE(a,n)  ({ register unsigned int ret;   \</span>
00248 <span class="preprocessor">                asm (           \</span>
00249 <span class="preprocessor">                "rlwinm %0,%1,%2,0,31"  \</span>
00250 <span class="preprocessor">                : "=r"(ret)     \</span>
00251 <span class="preprocessor">                : "r"(a), "I"(n));  \</span>
00252 <span class="preprocessor">               ret;             \</span>
00253 <span class="preprocessor">            })</span>
00254 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
00255 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
00256 <span class="preprocessor"></span>
00257 <span class="comment">/*</span>
00258 <span class="comment"> * Engage compiler specific "fetch in reverse byte order"</span>
00259 <span class="comment"> * intrinsic function if available.</span>
00260 <span class="comment"> */</span>
00261 <span class="preprocessor"># if defined(__GNUC__) &amp;&amp; __GNUC__&gt;=2 &amp;&amp; !defined(OPENSSL_NO_ASM) &amp;&amp; !defined(OPENSSL_NO_INLINE_ASM)</span>
00262 <span class="preprocessor"></span>  <span class="comment">/* some GNU C inline assembler templates by &lt;appro@fy.chalmers.se&gt; */</span>
00263 <span class="preprocessor">#  if (defined(__i386) || defined(__i386__) || defined(__x86_64) || defined(__x86_64__)) &amp;&amp; !defined(I386_ONLY)</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#   define BE_FETCH32(a)    ({ register unsigned int l=(a);\</span>
00265 <span class="preprocessor">                asm (           \</span>
00266 <span class="preprocessor">                "bswapl %0"     \</span>
00267 <span class="preprocessor">                : "=r"(l) : "0"(l));    \</span>
00268 <span class="preprocessor">              l;                \</span>
00269 <span class="preprocessor">            })</span>
00270 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(__powerpc)</span>
00271 <span class="preprocessor"></span><span class="preprocessor">#   define LE_FETCH32(a)    ({ register unsigned int l; \</span>
00272 <span class="preprocessor">                asm (           \</span>
00273 <span class="preprocessor">                "lwbrx %0,0,%1"     \</span>
00274 <span class="preprocessor">                : "=r"(l)       \</span>
00275 <span class="preprocessor">                : "r"(a));      \</span>
00276 <span class="preprocessor">               l;               \</span>
00277 <span class="preprocessor">            })</span>
00278 <span class="preprocessor"></span>
00279 <span class="preprocessor">#  elif defined(__sparc) &amp;&amp; defined(OPENSSL_SYS_ULTRASPARC)</span>
00280 <span class="preprocessor"></span><span class="preprocessor">#  define LE_FETCH32(a) ({ register unsigned int l;     \</span>
00281 <span class="preprocessor">                asm (               \</span>
00282 <span class="preprocessor">                "lda [%1]#ASI_PRIMARY_LITTLE,%0"\</span>
00283 <span class="preprocessor">                : "=r"(l)           \</span>
00284 <span class="preprocessor">                : "r"(a));          \</span>
00285 <span class="preprocessor">               l;                   \</span>
00286 <span class="preprocessor">            })</span>
00287 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
00288 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
00289 <span class="preprocessor"></span><span class="preprocessor">#endif                          </span><span class="comment">/* PEDANTIC */</span>
00290 
00291 <span class="preprocessor">#if HASH_LONG_LOG2==2           </span><span class="comment">/* Engage only if sizeof(HASH_LONG)== 4 */</span>
00292 <span class="comment">/* A nice byte order reversal from Wei Dai &lt;weidai@eskimo.com&gt; */</span>
00293 <span class="preprocessor">#ifdef ROTATE</span>
00294 <span class="preprocessor"></span><span class="comment">/* 5 instructions with rotate instruction, else 9 */</span>
00295 <span class="preprocessor">#define REVERSE_FETCH32(a,l)    (                   \</span>
00296 <span class="preprocessor">        l=*(const HASH_LONG *)(a),              \</span>
00297 <span class="preprocessor">        ((ROTATE(l,8)&amp;0x00FF00FF)|(ROTATE((l&amp;0x00FF00FF),24)))  \</span>
00298 <span class="preprocessor">                )</span>
00299 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00300 <span class="preprocessor"></span><span class="comment">/* 6 instructions with rotate instruction, else 8 */</span>
<a name="l00301"></a><a class="code" href="md32__common_8h.html#a2">00301</a> <span class="preprocessor">#define REVERSE_FETCH32(a,l)    (               \</span>
00302 <span class="preprocessor">        l=*(const HASH_LONG *)(a),          \</span>
00303 <span class="preprocessor">        l=(((l&gt;&gt;8)&amp;0x00FF00FF)|((l&amp;0x00FF00FF)&lt;&lt;8)),    \</span>
00304 <span class="preprocessor">        ROTATE(l,16)                    \</span>
00305 <span class="preprocessor">                )</span>
00306 <span class="preprocessor"></span><span class="comment">/*</span>
00307 <span class="comment"> * Originally the middle line started with l=(((l&amp;0xFF00FF00)&gt;&gt;8)|...</span>
00308 <span class="comment"> * It's rewritten as above for two reasons:</span>
00309 <span class="comment"> *      - RISCs aren't good at long constants and have to explicitely</span>
00310 <span class="comment"> *        compose 'em with several (well, usually 2) instructions in a</span>
00311 <span class="comment"> *        register before performing the actual operation and (as you</span>
00312 <span class="comment"> *        already realized:-) having same constant should inspire the</span>
00313 <span class="comment"> *        compiler to permanently allocate the only register for it;</span>
00314 <span class="comment"> *      - most modern CPUs have two ALUs, but usually only one has</span>
00315 <span class="comment"> *        circuitry for shifts:-( this minor tweak inspires compiler</span>
00316 <span class="comment"> *        to schedule shift instructions in a better way...</span>
00317 <span class="comment"> *</span>
00318 <span class="comment"> *                              &lt;appro@fy.chalmers.se&gt;</span>
00319 <span class="comment"> */</span>
00320 <span class="preprocessor">#endif</span>
00321 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00322 <span class="preprocessor"></span>
00323 <span class="preprocessor">#ifndef ROTATE</span>
<a name="l00324"></a><a class="code" href="md32__common_8h.html#a3">00324</a> <span class="preprocessor"></span><span class="preprocessor">#define ROTATE(a,n)     (((a)&lt;&lt;(n))|(((a)&amp;0xffffffff)&gt;&gt;(32-(n))))</span>
00325 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00326 <span class="preprocessor"></span>
00327 <span class="comment">/*</span>
00328 <span class="comment"> * Make some obvious choices. E.g., HASH_BLOCK_DATA_ORDER_ALIGNED</span>
00329 <span class="comment"> * and HASH_BLOCK_HOST_ORDER ought to be the same if input data</span>
00330 <span class="comment"> * and host are of the same "endianess". It's possible to mask</span>
00331 <span class="comment"> * this with blank #define HASH_BLOCK_DATA_ORDER though...</span>
00332 <span class="comment"> *</span>
00333 <span class="comment"> *                              &lt;appro@fy.chalmers.se&gt;</span>
00334 <span class="comment"> */</span>
00335 <span class="preprocessor">#if defined(B_ENDIAN)</span>
00336 <span class="preprocessor"></span><span class="preprocessor">#  if defined(DATA_ORDER_IS_BIG_ENDIAN)</span>
00337 <span class="preprocessor"></span><span class="preprocessor">#    if !defined(HASH_BLOCK_DATA_ORDER_ALIGNED) &amp;&amp; HASH_LONG_LOG2==2</span>
00338 <span class="preprocessor"></span><span class="preprocessor">#      define HASH_BLOCK_DATA_ORDER_ALIGNED HASH_BLOCK_HOST_ORDER</span>
00339 <span class="preprocessor"></span><span class="preprocessor">#    endif</span>
00340 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)</span>
00341 <span class="preprocessor"></span><span class="preprocessor">#    ifndef HOST_FETCH32</span>
00342 <span class="preprocessor"></span><span class="preprocessor">#      ifdef LE_FETCH32</span>
00343 <span class="preprocessor"></span><span class="preprocessor">#        define HOST_FETCH32(p,l)   LE_FETCH32(p)</span>
00344 <span class="preprocessor"></span><span class="preprocessor">#      elif defined(REVERSE_FETCH32)</span>
00345 <span class="preprocessor"></span><span class="preprocessor">#        define HOST_FETCH32(p,l)   REVERSE_FETCH32(p,l)</span>
00346 <span class="preprocessor"></span><span class="preprocessor">#      endif</span>
00347 <span class="preprocessor"></span><span class="preprocessor">#    endif</span>
00348 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
00349 <span class="preprocessor"></span><span class="preprocessor">#elif defined(L_ENDIAN)</span>
00350 <span class="preprocessor"></span><span class="preprocessor">#  if defined(DATA_ORDER_IS_LITTLE_ENDIAN)</span>
00351 <span class="preprocessor"></span><span class="preprocessor">#    if !defined(HASH_BLOCK_DATA_ORDER_ALIGNED) &amp;&amp; HASH_LONG_LOG2==2</span>
00352 <span class="preprocessor"></span><span class="preprocessor">#      define HASH_BLOCK_DATA_ORDER_ALIGNED HASH_BLOCK_HOST_ORDER</span>
00353 <span class="preprocessor"></span><span class="preprocessor">#    endif</span>
00354 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(DATA_ORDER_IS_BIG_ENDIAN)</span>
00355 <span class="preprocessor"></span><span class="preprocessor">#    ifndef HOST_FETCH32</span>
00356 <span class="preprocessor"></span><span class="preprocessor">#      ifdef BE_FETCH32</span>
00357 <span class="preprocessor"></span><span class="preprocessor">#        define HOST_FETCH32(p,l)   BE_FETCH32(p)</span>
00358 <span class="preprocessor"></span><span class="preprocessor">#      elif defined(REVERSE_FETCH32)</span>
00359 <span class="preprocessor"></span><span class="preprocessor">#        define HOST_FETCH32(p,l)   REVERSE_FETCH32(p,l)</span>
00360 <span class="preprocessor"></span><span class="preprocessor">#      endif</span>
00361 <span class="preprocessor"></span><span class="preprocessor">#    endif</span>
00362 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
00363 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00364 <span class="preprocessor"></span>
00365 <span class="preprocessor">#if !defined(HASH_BLOCK_DATA_ORDER_ALIGNED)</span>
00366 <span class="preprocessor"></span><span class="preprocessor">#ifndef HASH_BLOCK_DATA_ORDER</span>
00367 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_BLOCK_DATA_ORDER must be defined!"</span>
00368 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00369 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00370 <span class="preprocessor"></span>
00371 <span class="preprocessor">#if defined(DATA_ORDER_IS_BIG_ENDIAN)</span>
00372 <span class="preprocessor"></span>
00373 <span class="preprocessor">#define HOST_c2l(c,l)   (l =(((unsigned long)(*((c)++)))&lt;&lt;24),      \</span>
00374 <span class="preprocessor">             l|=(((unsigned long)(*((c)++)))&lt;&lt;16),      \</span>
00375 <span class="preprocessor">             l|=(((unsigned long)(*((c)++)))&lt;&lt; 8),      \</span>
00376 <span class="preprocessor">             l|=(((unsigned long)(*((c)++)))    ),      \</span>
00377 <span class="preprocessor">             l)</span>
00378 <span class="preprocessor"></span><span class="preprocessor">#define HOST_p_c2l(c,l,n)   {                   \</span>
00379 <span class="preprocessor">            switch (n) {                    \</span>
00380 <span class="preprocessor">            case 0: l =((unsigned long)(*((c)++)))&lt;&lt;24; \</span>
00381 <span class="preprocessor">            case 1: l|=((unsigned long)(*((c)++)))&lt;&lt;16; \</span>
00382 <span class="preprocessor">            case 2: l|=((unsigned long)(*((c)++)))&lt;&lt; 8; \</span>
00383 <span class="preprocessor">            case 3: l|=((unsigned long)(*((c)++)));     \</span>
00384 <span class="preprocessor">                } }</span>
00385 <span class="preprocessor"></span><span class="preprocessor">#define HOST_p_c2l_p(c,l,sc,len) {                  \</span>
00386 <span class="preprocessor">            switch (sc) {                   \</span>
00387 <span class="preprocessor">            case 0: l =((unsigned long)(*((c)++)))&lt;&lt;24; \</span>
00388 <span class="preprocessor">                if (--len == 0) break;          \</span>
00389 <span class="preprocessor">            case 1: l|=((unsigned long)(*((c)++)))&lt;&lt;16; \</span>
00390 <span class="preprocessor">                if (--len == 0) break;          \</span>
00391 <span class="preprocessor">            case 2: l|=((unsigned long)(*((c)++)))&lt;&lt; 8; \</span>
00392 <span class="preprocessor">                } }</span>
00393 <span class="preprocessor"></span><span class="comment">/* NOTE the pointer is not incremented at the end of this */</span>
00394 <span class="preprocessor">#define HOST_c2l_p(c,l,n)   {                   \</span>
00395 <span class="preprocessor">            l=0; (c)+=n;                    \</span>
00396 <span class="preprocessor">            switch (n) {                    \</span>
00397 <span class="preprocessor">            case 3: l =((unsigned long)(*(--(c))))&lt;&lt; 8; \</span>
00398 <span class="preprocessor">            case 2: l|=((unsigned long)(*(--(c))))&lt;&lt;16; \</span>
00399 <span class="preprocessor">            case 1: l|=((unsigned long)(*(--(c))))&lt;&lt;24; \</span>
00400 <span class="preprocessor">                } }</span>
00401 <span class="preprocessor"></span><span class="preprocessor">#define HOST_l2c(l,c)   (*((c)++)=(unsigned char)(((l)&gt;&gt;24)&amp;0xff),  \</span>
00402 <span class="preprocessor">             *((c)++)=(unsigned char)(((l)&gt;&gt;16)&amp;0xff),  \</span>
00403 <span class="preprocessor">             *((c)++)=(unsigned char)(((l)&gt;&gt; 8)&amp;0xff),  \</span>
00404 <span class="preprocessor">             *((c)++)=(unsigned char)(((l)    )&amp;0xff),  \</span>
00405 <span class="preprocessor">             l)</span>
00406 <span class="preprocessor"></span>
00407 <span class="preprocessor">#elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)</span>
00408 <span class="preprocessor"></span>
00409 <span class="preprocessor">#define HOST_c2l(c,l)   (l =(((unsigned long)(*((c)++)))    ),      \</span>
00410 <span class="preprocessor">             l|=(((unsigned long)(*((c)++)))&lt;&lt; 8),      \</span>
00411 <span class="preprocessor">             l|=(((unsigned long)(*((c)++)))&lt;&lt;16),      \</span>
00412 <span class="preprocessor">             l|=(((unsigned long)(*((c)++)))&lt;&lt;24),      \</span>
00413 <span class="preprocessor">             l)</span>
00414 <span class="preprocessor"></span><span class="preprocessor">#define HOST_p_c2l(c,l,n)   {                   \</span>
00415 <span class="preprocessor">            switch (n) {                    \</span>
00416 <span class="preprocessor">            case 0: l =((unsigned long)(*((c)++)));     \</span>
00417 <span class="preprocessor">            case 1: l|=((unsigned long)(*((c)++)))&lt;&lt; 8; \</span>
00418 <span class="preprocessor">            case 2: l|=((unsigned long)(*((c)++)))&lt;&lt;16; \</span>
00419 <span class="preprocessor">            case 3: l|=((unsigned long)(*((c)++)))&lt;&lt;24; \</span>
00420 <span class="preprocessor">                } }</span>
00421 <span class="preprocessor"></span><span class="preprocessor">#define HOST_p_c2l_p(c,l,sc,len) {                  \</span>
00422 <span class="preprocessor">            switch (sc) {                   \</span>
00423 <span class="preprocessor">            case 0: l =((unsigned long)(*((c)++)));     \</span>
00424 <span class="preprocessor">                if (--len == 0) break;          \</span>
00425 <span class="preprocessor">            case 1: l|=((unsigned long)(*((c)++)))&lt;&lt; 8; \</span>
00426 <span class="preprocessor">                if (--len == 0) break;          \</span>
00427 <span class="preprocessor">            case 2: l|=((unsigned long)(*((c)++)))&lt;&lt;16; \</span>
00428 <span class="preprocessor">                } }</span>
00429 <span class="preprocessor"></span><span class="comment">/* NOTE the pointer is not incremented at the end of this */</span>
00430 <span class="preprocessor">#define HOST_c2l_p(c,l,n)   {                   \</span>
00431 <span class="preprocessor">            l=0; (c)+=n;                    \</span>
00432 <span class="preprocessor">            switch (n) {                    \</span>
00433 <span class="preprocessor">            case 3: l =((unsigned long)(*(--(c))))&lt;&lt;16; \</span>
00434 <span class="preprocessor">            case 2: l|=((unsigned long)(*(--(c))))&lt;&lt; 8; \</span>
00435 <span class="preprocessor">            case 1: l|=((unsigned long)(*(--(c))));     \</span>
00436 <span class="preprocessor">                } }</span>
00437 <span class="preprocessor"></span><span class="preprocessor">#define HOST_l2c(l,c)   (*((c)++)=(unsigned char)(((l)    )&amp;0xff),  \</span>
00438 <span class="preprocessor">             *((c)++)=(unsigned char)(((l)&gt;&gt; 8)&amp;0xff),  \</span>
00439 <span class="preprocessor">             *((c)++)=(unsigned char)(((l)&gt;&gt;16)&amp;0xff),  \</span>
00440 <span class="preprocessor">             *((c)++)=(unsigned char)(((l)&gt;&gt;24)&amp;0xff),  \</span>
00441 <span class="preprocessor">             l)</span>
00442 <span class="preprocessor"></span>
00443 <span class="preprocessor">#endif</span>
00444 <span class="preprocessor"></span>
00445 <span class="comment">/*</span>
00446 <span class="comment"> * Time for some action:-)</span>
00447 <span class="comment"> */</span>
00448 
00449 <span class="preprocessor">#ifndef OCTEON_OPENSSL</span>
00450 <span class="preprocessor"></span><span class="keywordtype">int</span>
00451 <a class="code" href="md5__locl_8h.html#a7">HASH_UPDATE</a> (HASH_CTX * c, <span class="keyword">const</span> <span class="keywordtype">void</span> *data_, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="x509_8h.html#a176">len</a>)
00452 {
00453   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = data_;
00454   <span class="keyword">register</span> HASH_LONG *p;
00455   <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="cryptlib_8c.html#a6">l</a>;
00456   <span class="keywordtype">int</span> sw, sc, ew, ec;
00457   <span class="keywordflow">if</span> (<a class="code" href="x509_8h.html#a176">len</a> == 0)
00458     <span class="keywordflow">return</span> 1;
00459 
00460   <a class="code" href="cryptlib_8c.html#a6">l</a> = (c-&gt;Nl + (<a class="code" href="x509_8h.html#a176">len</a> &lt;&lt; 3)) &amp; 0xffffffffL;
00461   <span class="comment">/* 95-05-24 eay Fixed a bug with the overflow handling, thanks to</span>
00462 <span class="comment">   * Wei Dai &lt;weidai@eskimo.com&gt; for pointing it out. */</span>
00463   <span class="keywordflow">if</span> (<a class="code" href="cryptlib_8c.html#a6">l</a> &lt; c-&gt;Nl)                <span class="comment">/* overflow */</span>
00464     c-&gt;Nh++;
00465   c-&gt;Nh += (<a class="code" href="x509_8h.html#a176">len</a> &gt;&gt; 29);
00466   c-&gt;Nl = <a class="code" href="cryptlib_8c.html#a6">l</a>;
00467 
00468   <span class="keywordflow">if</span> (c-&gt;num != 0) {
00469     p = c-&gt;data;
00470     sw = c-&gt;num &gt;&gt; 2;
00471     sc = c-&gt;num &amp; 0x03;
00472 
00473     <span class="keywordflow">if</span> ((c-&gt;num + <a class="code" href="x509_8h.html#a176">len</a>) &gt;= HASH_CBLOCK) {
00474       <a class="code" href="cryptlib_8c.html#a6">l</a> = p[sw];
00475       HOST_p_c2l (data, <a class="code" href="cryptlib_8c.html#a6">l</a>, sc);
00476       p[sw++] = <a class="code" href="cryptlib_8c.html#a6">l</a>;
00477       <span class="keywordflow">for</span> (; sw &lt; <a class="code" href="md32__common_8h.html#a0">HASH_LBLOCK</a>; sw++) {
00478         HOST_c2l (data, <a class="code" href="cryptlib_8c.html#a6">l</a>);
00479         p[sw] = <a class="code" href="cryptlib_8c.html#a6">l</a>;
00480       }
00481       <a class="code" href="md5__locl_8h.html#a11">HASH_BLOCK_HOST_ORDER</a> (c, p, 1);
00482       <a class="code" href="x509_8h.html#a176">len</a> -= (HASH_CBLOCK - c-&gt;num);
00483       c-&gt;num = 0;
00484       <span class="comment">/* drop through and do the rest */</span>
00485     } <span class="keywordflow">else</span> {
00486       c-&gt;num += <a class="code" href="x509_8h.html#a176">len</a>;
00487       <span class="keywordflow">if</span> ((sc + <a class="code" href="x509_8h.html#a176">len</a>) &lt; 4) {     <span class="comment">/* ugly, add char's to a word */</span>
00488         <a class="code" href="cryptlib_8c.html#a6">l</a> = p[sw];
00489         HOST_p_c2l_p (data, <a class="code" href="cryptlib_8c.html#a6">l</a>, sc, <a class="code" href="x509_8h.html#a176">len</a>);
00490         p[sw] = <a class="code" href="cryptlib_8c.html#a6">l</a>;
00491       } <span class="keywordflow">else</span> {
00492         ew = (c-&gt;num &gt;&gt; 2);
00493         ec = (c-&gt;num &amp; 0x03);
00494         <span class="keywordflow">if</span> (sc)
00495           <a class="code" href="cryptlib_8c.html#a6">l</a> = p[sw];
00496         HOST_p_c2l (data, <a class="code" href="cryptlib_8c.html#a6">l</a>, sc);
00497         p[sw++] = <a class="code" href="cryptlib_8c.html#a6">l</a>;
00498         <span class="keywordflow">for</span> (; sw &lt; ew; sw++) {
00499           HOST_c2l (data, <a class="code" href="cryptlib_8c.html#a6">l</a>);
00500           p[sw] = <a class="code" href="cryptlib_8c.html#a6">l</a>;
00501         }
00502         <span class="keywordflow">if</span> (ec) {
00503           HOST_c2l_p (data, <a class="code" href="cryptlib_8c.html#a6">l</a>, ec);
00504           p[sw] = <a class="code" href="cryptlib_8c.html#a6">l</a>;
00505         }
00506       }
00507       <span class="keywordflow">return</span> 1;
00508     }
00509   }
00510 
00511   sw = <a class="code" href="x509_8h.html#a176">len</a> / HASH_CBLOCK;
00512   <span class="keywordflow">if</span> (sw &gt; 0) {
00513 <span class="preprocessor">#if defined(HASH_BLOCK_DATA_ORDER_ALIGNED)</span>
00514 <span class="preprocessor"></span>    <span class="comment">/*</span>
00515 <span class="comment">     * Note that HASH_BLOCK_DATA_ORDER_ALIGNED gets defined</span>
00516 <span class="comment">     * only if sizeof(HASH_LONG)==4.</span>
00517 <span class="comment">     */</span>
00518     <span class="keywordflow">if</span> ((((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) data) % 4) == 0) {
00519       <span class="comment">/* data is properly aligned so that we can cast it: */</span>
00520       HASH_BLOCK_DATA_ORDER_ALIGNED (c, (HASH_LONG *) data, sw);
00521       sw *= HASH_CBLOCK;
00522       data += sw;
00523       <a class="code" href="x509_8h.html#a176">len</a> -= sw;
00524     } <span class="keywordflow">else</span>
00525 <span class="preprocessor">#if !defined(HASH_BLOCK_DATA_ORDER)</span>
00526 <span class="preprocessor"></span>      <span class="keywordflow">while</span> (sw--) {
00527         memcpy (p = c-&gt;data, data, HASH_CBLOCK);
00528         HASH_BLOCK_DATA_ORDER_ALIGNED (c, p, 1);
00529         data += HASH_CBLOCK;
00530         <a class="code" href="x509_8h.html#a176">len</a> -= HASH_CBLOCK;
00531       }
00532 <span class="preprocessor">#endif</span>
00533 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00534 <span class="preprocessor"></span><span class="preprocessor">#if defined(HASH_BLOCK_DATA_ORDER)</span>
00535 <span class="preprocessor"></span>    {
00536       <a class="code" href="md5__locl_8h.html#a12">HASH_BLOCK_DATA_ORDER</a> (c, data, sw);
00537       sw *= HASH_CBLOCK;
00538       data += sw;
00539       <a class="code" href="x509_8h.html#a176">len</a> -= sw;
00540     }
00541 <span class="preprocessor">#endif</span>
00542 <span class="preprocessor"></span>  }
00543 
00544   <span class="keywordflow">if</span> (<a class="code" href="x509_8h.html#a176">len</a> != 0) {
00545     p = c-&gt;<a class="code" href="structasn1__object__st.html#m4">data</a>;
00546     c-&gt;num = <a class="code" href="x509_8h.html#a176">len</a>;
00547     ew = <a class="code" href="x509_8h.html#a176">len</a> &gt;&gt; 2;              <span class="comment">/* words to copy */</span>
00548     ec = <a class="code" href="x509_8h.html#a176">len</a> &amp; 0x03;
00549     <span class="keywordflow">for</span> (; ew; ew--, p++) {
00550       HOST_c2l (data, <a class="code" href="cryptlib_8c.html#a6">l</a>);
00551       *p = <a class="code" href="cryptlib_8c.html#a6">l</a>;
00552     }
00553     HOST_c2l_p (data, <a class="code" href="cryptlib_8c.html#a6">l</a>, ec);
00554     *p = <a class="code" href="cryptlib_8c.html#a6">l</a>;
00555   }
00556   <span class="keywordflow">return</span> 1;
00557 }
00558 <span class="preprocessor">#endif                          </span><span class="comment">/* Octeon Openssl */</span>
00559 
00560 <span class="keywordtype">void</span>
00561 <a class="code" href="md5__locl_8h.html#a8">HASH_TRANSFORM</a> (HASH_CTX * c, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data)
00562 {
00563 <span class="preprocessor">#if defined(HASH_BLOCK_DATA_ORDER_ALIGNED)</span>
00564 <span class="preprocessor"></span>  <span class="keywordflow">if</span> ((((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) data) % 4) == 0)
00565     <span class="comment">/* data is properly aligned so that we can cast it: */</span>
00566     HASH_BLOCK_DATA_ORDER_ALIGNED (c, (HASH_LONG *) data, 1);
00567   <span class="keywordflow">else</span>
00568 <span class="preprocessor">#if !defined(HASH_BLOCK_DATA_ORDER)</span>
00569 <span class="preprocessor"></span>  {
00570     memcpy (c-&gt;data, data, HASH_CBLOCK);
00571     HASH_BLOCK_DATA_ORDER_ALIGNED (c, c-&gt;data, 1);
00572   }
00573 <span class="preprocessor">#endif</span>
00574 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00575 <span class="preprocessor"></span><span class="preprocessor">#if defined(HASH_BLOCK_DATA_ORDER)</span>
00576 <span class="preprocessor"></span>  <a class="code" href="md5__locl_8h.html#a12">HASH_BLOCK_DATA_ORDER</a> (c, data, 1);
00577 <span class="preprocessor">#endif</span>
00578 <span class="preprocessor"></span>}
00579 
00580 <span class="preprocessor">#ifndef OCTEON_OPENSSL</span>
00581 <span class="preprocessor"></span><span class="keywordtype">int</span>
00582 <a class="code" href="md5__locl_8h.html#a9">HASH_FINAL</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *md, HASH_CTX * c)
00583 {
00584   <span class="keyword">register</span> HASH_LONG *p;
00585   <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="cryptlib_8c.html#a6">l</a>;
00586   <span class="keyword">register</span> <span class="keywordtype">int</span> i, j;
00587   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> end[4] = { 0x80, 0x00, 0x00, 0x00 };
00588   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *cp = end;
00589 
00590   <span class="comment">/* c-&gt;num should definitly have room for at least one more byte. */</span>
00591   p = c-&gt;data;
00592   i = c-&gt;num &gt;&gt; 2;
00593   j = c-&gt;num &amp; 0x03;
00594 
00595 <span class="preprocessor">#if 0</span>
00596 <span class="preprocessor"></span>  <span class="comment">/* purify often complains about the following line as an</span>
00597 <span class="comment">   * Uninitialized Memory Read.  While this can be true, the</span>
00598 <span class="comment">   * following p_c2l macro will reset l when that case is true.</span>
00599 <span class="comment">   * This is because j&amp;0x03 contains the number of 'valid' bytes</span>
00600 <span class="comment">   * already in p[i].  If and only if j&amp;0x03 == 0, the UMR will</span>
00601 <span class="comment">   * occur but this is also the only time p_c2l will do</span>
00602 <span class="comment">   * l= *(cp++) instead of l|= *(cp++)</span>
00603 <span class="comment">   * Many thanks to Alex Tang &lt;altitude@cic.net&gt; for pickup this</span>
00604 <span class="comment">   * 'potential bug' */</span>
00605 <span class="preprocessor">#ifdef PURIFY</span>
00606 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (j == 0)
00607     p[i] = 0;                   <span class="comment">/* Yeah, but that's not the way to fix it:-) */</span>
00608 <span class="preprocessor">#endif</span>
00609 <span class="preprocessor"></span>  <a class="code" href="cryptlib_8c.html#a6">l</a> = p[i];
00610 <span class="preprocessor">#else</span>
00611 <span class="preprocessor"></span>  <a class="code" href="cryptlib_8c.html#a6">l</a> = (j == 0) ? 0 : p[i];
00612 <span class="preprocessor">#endif</span>
00613 <span class="preprocessor"></span>  HOST_p_c2l (cp, <a class="code" href="cryptlib_8c.html#a6">l</a>, j);
00614   p[i++] = <a class="code" href="cryptlib_8c.html#a6">l</a>;                   <span class="comment">/* i is the next 'undefined word' */</span>
00615 
00616   <span class="keywordflow">if</span> (i &gt; (<a class="code" href="md32__common_8h.html#a0">HASH_LBLOCK</a> - 2)) {  <span class="comment">/* save room for Nl and Nh */</span>
00617     <span class="keywordflow">if</span> (i &lt; <a class="code" href="md32__common_8h.html#a0">HASH_LBLOCK</a>)
00618       p[i] = 0;
00619     <a class="code" href="md5__locl_8h.html#a11">HASH_BLOCK_HOST_ORDER</a> (c, p, 1);
00620     i = 0;
00621   }
00622   <span class="keywordflow">for</span> (; i &lt; (<a class="code" href="md32__common_8h.html#a0">HASH_LBLOCK</a> - 2); i++)
00623     p[i] = 0;
00624 
00625 <span class="preprocessor">#if   defined(DATA_ORDER_IS_BIG_ENDIAN)</span>
00626 <span class="preprocessor"></span>  p[<a class="code" href="md32__common_8h.html#a0">HASH_LBLOCK</a> - 2] = c-&gt;Nh;
00627   p[<a class="code" href="md32__common_8h.html#a0">HASH_LBLOCK</a> - 1] = c-&gt;Nl;
00628 <span class="preprocessor">#elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)</span>
00629 <span class="preprocessor"></span>  p[<a class="code" href="md32__common_8h.html#a0">HASH_LBLOCK</a> - 2] = c-&gt;Nl;
00630   p[<a class="code" href="md32__common_8h.html#a0">HASH_LBLOCK</a> - 1] = c-&gt;Nh;
00631 <span class="preprocessor">#endif</span>
00632 <span class="preprocessor"></span>  <a class="code" href="md5__locl_8h.html#a11">HASH_BLOCK_HOST_ORDER</a> (c, p, 1);
00633 
00634 <span class="preprocessor">#ifndef HASH_MAKE_STRING</span>
00635 <span class="preprocessor"></span><span class="preprocessor">#error "HASH_MAKE_STRING must be defined!"</span>
00636 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00637 <span class="preprocessor"></span>  <a class="code" href="md5__locl_8h.html#a10">HASH_MAKE_STRING</a> (c, md);
00638 <span class="preprocessor">#endif</span>
00639 <span class="preprocessor"></span>
00640   c-&gt;num = 0;
00641   <span class="comment">/* clear stuff, HASH_BLOCK may be leaving some stuff on the stack</span>
00642 <span class="comment">   * but I'm not worried :-)</span>
00643 <span class="comment">   OPENSSL_cleanse((void *)c,sizeof(HASH_CTX));</span>
00644 <span class="comment">   */</span>
00645   <span class="keywordflow">return</span> 1;
00646 }
00647 <span class="preprocessor">#endif</span>
00648 <span class="preprocessor"></span>
00649 <span class="preprocessor">#ifndef MD32_REG_T</span>
00650 <span class="preprocessor"></span><span class="preprocessor">#define MD32_REG_T long</span>
00651 <span class="preprocessor"></span><span class="comment">/*</span>
00652 <span class="comment"> * This comment was originaly written for MD5, which is why it</span>
00653 <span class="comment"> * discusses A-D. But it basically applies to all 32-bit digests,</span>
00654 <span class="comment"> * which is why it was moved to common header file.</span>
00655 <span class="comment"> *</span>
00656 <span class="comment"> * In case you wonder why A-D are declared as long and not</span>
00657 <span class="comment"> * as MD5_LONG. Doing so results in slight performance</span>
00658 <span class="comment"> * boost on LP64 architectures. The catch is we don't</span>
00659 <span class="comment"> * really care if 32 MSBs of a 64-bit register get polluted</span>
00660 <span class="comment"> * with eventual overflows as we *save* only 32 LSBs in</span>
00661 <span class="comment"> * *either* case. Now declaring 'em long excuses the compiler</span>
00662 <span class="comment"> * from keeping 32 MSBs zeroed resulting in 13% performance</span>
00663 <span class="comment"> * improvement under SPARC Solaris7/64 and 5% under AlphaLinux.</span>
00664 <span class="comment"> * Well, to be honest it should say that this *prevents* </span>
00665 <span class="comment"> * performance degradation.</span>
00666 <span class="comment"> *                              &lt;appro@fy.chalmers.se&gt;</span>
00667 <span class="comment"> * Apparently there're LP64 compilers that generate better</span>
00668 <span class="comment"> * code if A-D are declared int. Most notably GCC-x86_64</span>
00669 <span class="comment"> * generates better code.</span>
00670 <span class="comment"> *                              &lt;appro@fy.chalmers.se&gt;</span>
00671 <span class="comment"> */</span>
00672 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Mon Aug 14 19:59:36 2006 for Octeon Core Crypto API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
